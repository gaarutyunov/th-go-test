## Тестовое задание для Go разраба

### ТЗ

* Необходимо реализовать два приложения: клиент и сервер.
* Общение между клиентом и сервером может осуществляться как угодно:
  * HTTP
  * TCP
  * через файлы
  * и т.п.

#### Сервер

* В сервере должны быть реализована очередь сообщений
* У очереди должна быть ограниченная емкость (например: 10)
* Сервер должен уметь оповещать клиента о том, что очередь заполнена
* Сервер должен уметь класть сообщения в очередь
* Сервер должен отдавать все сообщения из очереди
* У сообщения в очереди должен быть владелец
* Сообщение, которое положил в очередь владелец, может забрать только владелец
* После того как владелец забрал все сообщения, они удаляются из очереди
* Сообщения хранятся в памяти, они не сохраняются на диск

##### Технические требования к очереди

* Нужно использовать каналы
* Можно использовать механизмы синхронизации, если они понадобятся (mutex и др.)

##### Бонусное задание

Бонусное задание делать не обязательно, но оно покажет дополнительные навыки и в целом полезно.

* При отключении сервер должен складывать все сообщения в персистентное хранилище (например в файл)
* Такое отключение называется gracefull shutdown
* Пока сервер отключается, никто не должен иметь возможность записать в очередь
* При включении сервер зачитывает все сообщения из персистентого хранилища и кладет в очередь

#### Клиент

* При запуске у клиента должен появляться идентификатор
  * Можно запрашивать его из терминала
  * Можно генерировать случайного число
  * Можно использовать PID
  * Можно использовать uuid
  * и т.п.
* Клиент должен уметь отправлять сообщения серверу со своим идентификатором
* Клиент должен уметь зачитывать сообщения, которые он отправил ранее серверу со своим идентификатором
* Клиентов может быть запущено несколько и все они будут посылать сообщения серверу

##### Бонусное задание

Бонусное задание делать не обязательно, но оно покажет дополнительные навыки и в целом полезно.

* У клиента должна быть внутренняя очередь
* Если сервер отказал клиенту в отправке сообщений (сервер упал, очередь на сервере заполнена), то клиент должен ждать, пока очередь не освободится, чтобы положить туда сообщения из своей внутренней очереди
* Такая очередь находится в памяти, писать ее в персистентное хранилище после отключения не надо

### Инструкция к репке

#### Структура

* cmd/server/main.go - Точка входа серверного приложения
* cmd/client/main.go - Здесь точка входа клиентского приложения
* internal - Весь внутренний код
* pkg - Все пакеты, написанные внутри приложение

Необязательно использовать и internal и pkg. Можно писать весь код в internal или писать все в виде пакетов.

#### Команды

* `make help` - Показать все доступные команды
* `make setup` - Настройка репозитория: установка зависимостей
* `make check` - Линтер и форматирование
* `make build-server` - Собрать серверное приложение
* `make build-client` - Собрать клиента

### Как выполнять задание

1. Нужно создать fork репозитория
2. Написать там код
3. Создать Pull Request в development ветку